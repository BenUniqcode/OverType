<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"> 
		<title>Ben's Super-Realistic Typewriter Simulator</title>
		<style type="text/css" media="all">
			body {
				font-family: Helvetica, sans-serif;
				font-size: 10pt;
				background-color: #eee;
				margin: 0;
			}
			h1 {
				margin: 0;
				font-family: Courier, "Courier New", monospace;
				font-weight: normal;
				font-size: 32px;
			}
			h2 {
				font-size: 12pt;
			}
			h3 {
				font-size: 11pt;
			}
			#input {
				position: absolute;
				left: -1000px;
				top: -1000px;
			}
			.topbar {
				position: absolute;
				top: 0;
				left: 0;
				background-color: #aaa;
				z-index: 5;
				padding: 1ex 2% 0 1%;
				height: 10ex;
				width: 97%;
			}
			.info {
				position: absolute;
				top: 6em;
				padding: 1em;
				width: 70%;
				margin-left: auto;
				margin-right: auto;
			}
			.instruct {
				font-size: 20pt;
				color: #666;
			}
			.output {
				font-family: Courier, "Courier New", monospace;
				font-size: 20px;
				line-height: 30px;
				position: absolute;
				left: 5em;
				top: 3em;
				margin-bottom: 2em;
				width: 48em;
				height: 120ex;
				background-color: white;
				border: 1px solid black;
				padding: 8ex 2em;
				box-shadow: 8px 8px 4px #888;
				white-space: nowrap;
				z-index: 2;
				display: none;
			}
			.cursor {
				position: absolute;
				z-index: 3;
				width: 12px;
				height: 20px;
				border-bottom: 2px solid red;
				display: none;
			}
			.title {
				float: left;
			}
			.controls {
				margin: 0 1em;
				float: right;
			}
			.control {
				float: left;
				width: 140px;
				margin: 0 1ex;
			}
			.control p {
				margin: 0 0 8px 0;
				text-align: center;
			}
			.control .disp {
				margin: 4px 0 0 0;
				text-align: center;
			}
		</style>
		<style type="text/css" media="print">
			.cursor, .title, .instruct, #input { display: none }
			.output { left: 0 !important; top: 0 !important; box-shadow: none; border: none; padding: 10ex 0 0 0; }			
		</style>
		<!-- jQuery -->
		<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script type="text/javascript">window.jQuery || document.write( '<script type="text/javascript" src="assets/ion_sound_1.3.0/js/vendor/jquery-1.10.2.min.js"><\/script>' )</script>
		<!-- jQuery-UI -->
		<link rel="stylesheet" href="//ajax.googleapis.com/ajax/libs/jqueryui/1.10.4/themes/smoothness/jquery-ui.css" />
		<script src="//ajax.googleapis.com/ajax/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>		
		<!-- ION.Sound -->
		<script type="text/javascript" src="assets/ion_sound_1.3.0/js/ion-sound/ion.sound.min.js"></script>
		
		<script type="text/javascript">
			const bell_width = 69;
			const max_width = 80;
			const tab_width = 8;
			const unshifted = {
			   59: ';',
				 61: '=',
				173: '-',
				188: ',',
				190: '.',
				191: '/',
				192: '`',
				219: '[',
				220: '\\',
				221: ']',
				222: '\'',
			};
			const shifted = {
				48: ')',
				49: '!',
				50: '@',
				51: 'Â£',
				52: '$',
				53: '%',
				54: '^',
				55: '&',
				56: '*',
				57: '(',
				59: ':',
				61: '+',
				173: '_',
				188: '<',
				190: '>',
				191: '?',
				192: '~',
				219: '{',
				220: '|',
				221: '}',
				222: '"',
			};
			const xpx = 12, ypx = 30;
			const margin_top = 40, margin_left = 30;
			var x = max_width * xpx / 2;
			var y = 0;
			var backspaces = 0;
			var vmid = $(window).height() / 2;
			var hmid = $(window).width() / 2;
			var voffset = {};
			var broken = {};
			var keydown_mutex = false;
			var shift_mutex = false;
			var brokenness = 20;
			var ink_remaining = 400;
			var ink_variation = 0.3;
			var started = false;
			var redshift = false;

			function start() {			
				$('.info').hide();
				$('.output, .cursor, .controls').show();
				started = true;
			}
			
			function handle_keypress(e) {	
				if (! started) {
					start();
				}
				key = e.which;
				nosound = false;

				if (key == 16) { // shift
					if (shift_mutex) {
						return false;
					}
					$.ionSound.play('typewriter-spacebar');
					shift_mutex = true;
					return false;
				} 
				if (key == 18) { // alt = red-shift
					$.ionSound.play('typewriter-spacebar');
					redshift = true;
					return false;
				}				
				if (keydown_mutex) {
					return false;
				}
				keydown_mutex = true;
				if (key == 13) { // enter
					e.preventDefault();
					$.ionSound.play('typewriter-carriage-return');
					$('.output').append('<br/>');
					line_length = x / xpx;
					x = 0;
					backspaces = 0;
					y += ypx;
					return_time = 13 * line_length;
					$('.output').animate({
						top: (vmid - y) + 'px',
					}, 100).animate({
						left: (hmid - x) + 'px',
					}, return_time, function() {
						// Stop playing the sound when the animation completes
						$.ionSound.stop('typewriter-carriage-return');
					}); 
					return false;
				}
				if (key == 38) { // up-arrow
					if (y > 0) {
						y -= (ypx / 4);
						$.ionSound.play('typewriter-spacebar');
						move_page();
					}
					return false;
				}
				if (key == 40) { // down-arrow
					$.ionSound.play('typewriter-spacebar');
					y += (ypx / 4);
					move_page();
					return false;
				}
				if (key == 8 || key == 37) { // backspace, left-arrow
					if (x > 0) {
						x -= xpx;
						backspaces++;
						$.ionSound.play('typewriter-spacebar');
					} 
					return false;
				} 
				oldx = x;
				if (key == 9) { // tab
					e.preventDefault(); // Don't lose focus
					if (e.shiftKey) {
						var prev_tab_stop = ((x / xpx) % tab_width);
						if (prev_tab_stop == 0) {
							prev_tab_stop = tab_width;
						} 
						if ((x / xpx) - prev_tab_stop < 0) {
							prev_tab_stop = x;
						}
						x -= (prev_tab_stop * xpx); 
						backspaces += prev_tab_stop;
					} else {
						var next_tab_stop = tab_width - ((x / xpx) % tab_width);
						if (next_tab_stop == 0) {
							next_tab_stop = tab_width;
						} else if ((x / xpx) + next_tab_stop > max_width) {
							next_tab_stop = max_width - (x / xpx);
						}
						x += (next_tab_stop * xpx);
					}
					if ((oldx / xpx) < bell_width && (x / xpx) >= bell_width) {
						$.ionSound.play('typewriter-bell-2');
					}	else {				
						$.ionSound.play('typewriter-spacebar');
					}
					move_page();
					return false;
				}

				var c = String.fromCharCode(key);
				if (e.shiftKey) {
					if (c.match(/[A-Za-z]/)) {
						c = c.toUpperCase();
						ink_remaining--;
					} else if (shifted[key]) {
						c = shifted[key];
						ink_remaining--;
					} else {
						c = '&nbsp;';
					}
				} else if (c.match(/[A-Za-z0-9]/)) {
					c = c.toLowerCase();
					ink_remaining--;
				} else if (unshifted[key]) {
					c = unshifted[key];
					ink_remaining--;
				} else {
					c = '&nbsp;';
				}
				
				// Choose a greyscale colour with a random element to simulate uneven key pressure and ribbon ink
				var ink_level = (ink_remaining > 0) ? ink_remaining / 400 - ink_variation + Math.random() * ink_variation : 0;
								
				// Vertical offset
				if (! (c in voffset)) {
					voffset[c] = {
						threshold: Math.floor(Math.random() * 99) + 1, // 1..99
						direction: Math.floor(Math.random() * 3) - 1, // -1..+1
					}						
				}
				
				extra_offset = 0;
				// Extra offset if highly broken
				extra_offset = Math.floor(Math.random() * brokenness / 25); // 0 at b<50, 0..1 at 50<=b<75, 0..2 at b>=75
				if (voffset[c].direction < 0) {
					extra_offset = -extra_offset;
				}
				
				this_voffset = (voffset[c].threshold <= brokenness) ? Math.round(voffset[c].direction * brokenness / 33) : 0;
				this_voffset += extra_offset;
				
				// If brokenness >75%, let some keys be permanently broken.
				// The chance of a key being broken increases with brokenness; once broken, it remains so until brokenness is reduced
				// below 75% whereupon they are all fixed.
				if (brokenness > 75) {
					// Randomly break keys with a likelihood and a maximum number of broken keys that depend on the brokenness level
					if (c != '&nbsp;' && (broken[c] || (Math.random() * brokenness > 70 && Math.random() < 0.4 && Object.keys(broken).length < (brokenness - 75) / 5))) { 
						if (Math.random() > 0.7) {
							broken[c] = '&#9608;'; // full block - as if the embossed character has fallen off the arm.
						} else {
							broken[c] = '&nbsp;'; // as if the key doesn't work at all
							nosound = true;
						}
					}
				} else {
					broken = {};
				}

				// Output the character, unless it's broken
				if (broken[c]) {
					$('.output').append('<div style="position: absolute; top: ' + (y + margin_top) + 'px; left: ' + (x + margin_left) + 'px; color: rgba(0, 0, 0, ' + ink_level + ');">' + broken[c] + '</div>');
				} else {
					// If any part of the char is to be in red, print the whole char in red first, then overprint part of it in black
					var black_height_style = '';
					if (redshift) {
						$('.output').append('<div style="position: absolute; top: ' + (y + this_voffset + margin_top) + 'px; left: ' + (x + margin_left) + 'px; color: rgba(255, 0, 0, ' + ink_level + '); overflow: hidden; z-index: 99">' + c + '</div>');
						black_height = 0;
						if (Math.random() < brokenness / 100) {
							black_height = Math.round(Math.random() * ypx * brokenness / 100);
						} else {
							black_height = 0;
						}
						black_height_style = 'height: ' + black_height + 'px; '
					} else {
						black_height_style = '';
					}
					$('.output').append('<div style="position: absolute; top: ' + (y + this_voffset + margin_top) + 'px; left: ' + (x + margin_left) + 'px; color: rgba(0, 0, 0, ' + ink_level + '); ' + black_height_style + 'overflow: hidden; z-index: 100">' + c + '</div>');
				}
				
				if ((x / xpx) < max_width) {
					x += xpx;
				} else {
					backspaces++; // Fudge hard right margin without position:absolute
				}
				
				if ((oldx / xpx) < bell_width && (x / xpx) >= bell_width) {
					$.ionSound.play('typewriter-bell-2');
				} else if (key == 32 || key == 39) { // space, right-arrow
					$.ionSound.play('typewriter-spacebar');
				} else if (! nosound) {
					$.ionSound.play('typewriter-keydown');
				} 

				// Update ink level slider and disp
				$('#ctrl_inklevel').slider('option', 'value', ink_remaining);
				$('#disp_inklevel').html(ink_remaining);

				return false;
			}
			
			function move_page() {
				$('.output').animate({
					top: (vmid - y) + 'px',
					left: (hmid - x) + 'px',
				}, 20);
			}

			$(function() {
				// Sliders
				$('#ctrl_brokenness').slider({
					min: 0,
					max: 99,
					value: brokenness,
					slide: function(event, ui) {
						$('#disp_brokenness').html(ui.value);
					},						
					change: function(event, ui) {
						brokenness = ui.value;
						ink_variation = 1.0 * brokenness / 100;
					},
				});
				$('#ctrl_inklevel').slider({
					min: 0,
					max: 600,
					value: ink_remaining,
					slide: function(event, ui) {
						$('#disp_inklevel').html(ui.value);
					},						
					change: function(event, ui) {
						ink_remaining = ui.value;
					},
				});
				$('#disp_brokenness').html(brokenness);
				$('#disp_inklevel').html(ink_remaining);
				
				move_page();
				$('.cursor').css('top', vmid + 46).css('left', hmid + 32); // Magic numbers basically arrived at by trial and error...
				$.ionSound({
					path: "assets/typewriter_sounds/",
    			sounds: [
        		"typewriter-keydown",
        		"typewriter-keyup",
        		"typewriter-carriage-return",
        		"typewriter-spacebar",
        		"typewriter-bell-2",
    			],
    			multiPlay: true,
				});
				$('#input').val('').trigger('focus')
				.on('blur', function(e) { 
				  // A small delay seems to be necessary before forcing the focus back
				  e.preventDefault();
					setTimeout(function() {
						$('#input').trigger('focus'); 
					}, 20); 
				})
				.on('keydown', function(e) { // I originally used keypress, but this ignores backspace on Chrome
					handle_keypress(e); 
				})
				.on('keyup', function(e) {
					if (keydown_mutex && e.which != 16) {
						// Play the key release sound after a short delay
						setTimeout(function() {
							$.ionSound.play('typewriter-keyup');
						}, 65);
						move_page();
						// Wait till all animations have finished before releasing the mutex
						$(":animated").promise().done(function() {
							keydown_mutex = false;
						});
					} else if (shift_mutex && e.which == 16 && ! e.shiftKey) {
						$.ionSound.play('typewriter-keyup');
						shift_mutex = false;
					}	else if (redshift && e.which == 18) {
						$.ionSound.play('typewriter-keyup');
						redshift = false;
					}					
				}); // on()
			}); //$()
		</script>
	</head>
	<body>
		<textarea id="input">
		</textarea>
		<div class="topbar">
			<div class="title">
				<h1 style="margin-bottom: 0">Ben's Super-Realistic* Typewriter Simulator</h1>
				<p style="margin-top: 0"><small>* Neither realism nor superness guaranteed</small></p>
			</div>
			<div class="controls">
				<div class="control">
					<p>
						Brokenness
					</p>
					<div class="slider" id="ctrl_brokenness">
					</div>
					<div class="disp" id="disp_brokenness">
					</div>
				</div>
				<div class="control">
					<p>
						Ribbon inkiness
					</p>
					<div class="slider" id="ctrl_inklevel">
					</div>
					<div class="disp" id="disp_inklevel">
					</div>
				</div>
			</div>
		</div><!-- /topbar -->
		
		<div class="info">
			<h2>
				Why?
			</h2>
			<p>
				All the existing typewriter simulators that I've found on the web get one very basic thing wrong - when you press backspace, they erase the character you just typed, like a computer. On a real typewriter, backspace
				simply moves the carriage back one space, allowing you to overtype a previously typed character; so I have implemented
				it this way. If you want to erase a character, you need Tipp-Ex. (NB I do not advise using Tipp-Ex on your monitor). 
			</p>
			<h2>
				Yeah, but... WHY?
			</h2>
			<p>
				Because it's a fun thing to play with and also an interesting little development project - there's more of a challenge to the implementation than you might expect... 
			</p>
			<noscript>
				<p style="font-size: 36px">
					<b>You need to <a href="http://enable-javascript.com">enable Javascript in your browser</a> for this to work.</b>
				</p>
			</noscript>
			<h2>
				Instructions
			</h2>
			<div class="instruct">
				<ul>
					<li>Make sure you have your sound turned on for the fully-immersive experience!</li>
					<li>If it stops working or to see this text again, just reload the page.</li>
					<li>Ready? Just start typing, or click here if you prefer: <button style="font-size: large" onclick="start()">START!</button></li>
				</ul>
			</div>
			<h2>
				Sliders
			</h2>
			<p>
				Try out the sliders at the top of the screen. The ribbon ink reduces linearly, which is not how a real typewriter would work but gives a more pleasing result. The "brokenness" controls how uneven the vertical alignment and ink density are, and higher settings cause keys to start breaking (once a particular key has broken, it will never work again until you reduce the brokenness back down).
			</p>
			<h2>
				Known bugs
			</h2>
			<ul>
				<li>On Safari, the sounds are not synchronised. This is a Safari issue, and there doesn't seem to be anything I can do about it. Use Firefox or Chrome instead.</li>
			</ul>
			<h2>
				Improvements I'd like to make
			</h2>
			<ul>
				<li>If you type too fast or try to type two keys at once, the mechanism should jam. Amazingly, this is the most commonly requested feature from the early testers of this program. The only reason I haven't implemented it is the problem of designing a UI to represent unjamming it by picking the mechanism apart.</li>
				<li>Provide virtual Tipp-Ex.</li>
				<li>Further suggestions welcome (though remember this is just for fun!) to <a href="mailto:ben@uniqcode.com">ben@uniqcode.com</a></li>
			</ul>
			<h2>
				Credits
			</h2>
			<p>
				For Archie. Developed by Ben Wheeler @ <a href="http://uniqcode.com">UniqCode</a>, using <a href="http://jquery.com">jQuery</a> and
				<a href="https://github.com/IonDen/ion.sound">IonSound</a>. Typewriter sound effects from <a href="http://freesound.org">Freesound</a> and <a href="http://www.soundjay.com">SoundJay</a>, some of them edited by me. Tested on Firefox27/Mac and Chrome32/Mac. 			
			</p>
			<h2>
				Changelog
			</h2>
			<div class="changelog">
				<h3>
					version 1.15 (2014-02-15)
				</h3>
				<ul>

					<li>A better algorithm for mapping Brokenness to vertical offset.
					Rather than having a fixed offset for each character, and simply adding more
					random offset when Brokenness is increased, we now choose an offset and threshold
					for each character. If Brokenness is above the threshold for that char, it will be
					offset by its consistent amount. This offset may then be randomly boosted (or not)
					by 1 or 2px at high Brokenness levels.</li>

					<li>Brokenness now maxes at 99%, given that 100% brokenness would imply being
					completely non-functional.</li>

					<li>Show the values of the sliders as numbers below them.</li>
					
					<li>Reduce max inkiness.</li>
				</ul>
				<h3>
					version 1.14 (2014-02-12)
				</h3>
				<ul>
					<li>2-colour ribbon. Hold [alt] to type red characters. Sometimes these will randomly be only partially red, to simulate failing to press the colour shift key hard enough. The frequency and amount of this failure is affected by the Brokenness control.</li>
				</ul>
				<h3>
					version 1.13 (2014-02-12)
				</h3>
				<ul>
					<li>Sliders to control brokenness and inkiness.</li>
					<li>A high brokenness setting results in more wobbly and unevenly-inked text. Above 75%, the keys start to randomly break as you type, either failing to work at all (broken armature) or occasionally printing a solid block (armature works but letter has fallen off). A broken key never recovers until the brokenness is reduced back below this threshold, which unbreaks all of them.</li>
					<li>The inkiness slider also monitors your current ink level - ie it reduces as you type.</li>
					<li>Start from the centre of the top line of the page, instead of the top-left.</li>
				</ul>
				<h3>
					version 1.12 (2014-02-12)
				</h3>
				<ul>
					<li>Cursor key support. Left and right are the same as backspace and space. Up and down feed the paper by a quarter of a line height at a time.</li>
					<li>Use a position:absolute div for each character within position:relative output block. I had hoped this would allow me to do away with the input textarea altogether and bind the key handlers to $(document), but alas even with preventDefault(), some keypresses were still occasionally being passed through to the browser, causing it to scroll (space), go back a page (backspace) etc. Still, this way of positioning seems more flexible so I kept it.</li>
				</ul>
				<h3>
					version 1.11 (2014-02-12)
				</h3>
				<ul>
					<li>Change alpha level instead of colour to vary ink level. This seems to look more realistic and also means that
					if you overtype characters they get darker as they should.</li>
					<li>Reduce the likelihood of characters having vertical offset (while keeping the range the same at +/- 1px).</li> 
					<li>Play the CR bell for tabs and spaces as well as normal keys.</li>
					<li>Fix lines sometimes wrapping if you overtype a lot after a lot of backspaces.</li>
				</ul>
				<h3>
					version 1.10 (2014-02-11)
				</h3>
				<ul>
					<li>fix CSS font-family (whoops)</li>
					<li>per-char vertical offset was not being used consistently</li>
				</ul>		
				<h3>
					version 1.9 (2014-02-11)
				</h3>
				<ul>
					<li>Stylesheet for printing</li>
					<li>Increased space between lines</li>
				</ul>
				<h3>
					version 1.8 (2014-02-11)
				</h3>
				<ul>
					<li>The ribbon ink now gradually runs out, so the text becomes lighter the more characters you type.</li>
					<li>Reduced vertical offset, as it was just a tad too wibbly-wobbly.</li>
				</ul>
				<h3>
					version 1.7 (2014-02-11)
				</h3>
				<ul>
					<li>Prevent the hidden textarea from losing focus. It should now be safe to click anywhere on the page.</li>
					<li>Implemented tab stops every 8 chars - press TAB to jump to the next tab stop, SHIFT-TAB jumps to the previous one.</li>
				</ul>
				<h3>
					version 1.6 (2014-02-11)
				</h3>
				<ul>
					<li>If both shift keys are pressed, don't do the keyup sound until both are released.</li>
					<li>Round the vertical offset to an integer number of pixels.</li>
					<li>Don't release the keydown mutex until animations have finished. This limits typing speed and prevents being able to type a character onto the next line while a carriage return is in progress.</li>
				</ul>
				<h3>
					version 1.5 (2014-02-11)
				</h3>
				<ul>
					<li>Use a separate mutex for the shift key.</li>
					<li>Position the page on load so it doesn't jump after the first keypress.</li>
				</ul>
				<h3>
					version 1.4 (2014-02-11)
				</h3>
				<ul>
					<li>Move paper on keyup, not keydown.</li>
					<li>Use a mutex to ensure only one keypress is handled at a time, instead of a timeout (also fixes a long-held key generating two characters).</li>
					<li>Each character now has a consistent vertical offset (randomly chosen at the start), instead of randomly changing each time.</li>
					<li>Drop shadow on page.</li>
					<li>Fix page moving too far vertically on CR.</li>
				</ul>
				<h3>
					version 1.3 (2014-02-10)
				</h3>
				<ul>
					<li>The typed character now always appears in the centre of the screen; the "paper" moves.
		Movement of paper and carriage return are animated.</li>
					<li>A basic cursor to show where the next character will appear. This could eventually become an animated print head.</li>
					<li>Wibbly-wobbly text: A small random vertical offset is added to each character (suggested by David Gosnell)</li>
				</ul>

				<h3>
					version 1.2 (2014-02-10)
				</h3>
				<ul>
					<li>Don't allow backspacing past the beginning of the line.</li>
				</ul>
				<h3>
					version 1.1 (2014-02-10)
				</h3>
				<ul>
					<li>Separate sounds when keys are pressed and released, and for the shift key.</li>
					<li>Better (manual) carriage return sound.</li>
					<li>Limit the speed at which you can type.</li>
					<li>If you keep typing past the bell and hit the end of the line (80 characters), the carriage stops instead of continuing. In other words there is now a hard line length limit.</li>
					<li>Punctuation characters are handled (these are based on my UK Mac keyboard; unless you have the same keyboard some characters will probably be "wrong" for you.).</li>
					<li>Random variation of colour to simulate variations in key pressure and uneven ribbon ink.</li>
					<li>Hide all the informational text when you start typing, partly to give more space for both information and typing, but mostly to dodge the problem of trying to work out where to position the typewriter output so it doesn't crash the info.</li>
				</ul>
				<h3>
					version 1.0 (2014-02-09)
				</h3>
			</div><!-- /changelog -->			
		</div>
		<div class="output">
		</div>
		<div class="cursor">
		</div>
	</body>
</html>